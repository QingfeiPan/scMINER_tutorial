[["index.html", "scMINER: a mutual information-based framework for identifying hidden drivers from single-cell omics data ", " scMINER: a mutual information-based framework for identifying hidden drivers from single-cell omics data Qingfei Pan 2024-07-29 Welcome to scMINER documentation! scMINER (single-cell Mutual Information-based Network Engineering Ranger) is a computational framework designed for end-to-end analysis of single cell RNA-seq data. Using mutual information to measure cell-cell similarities and gene-gene correlations, scMINER is widely applicable and highly accurate in unsupervised clustering and gene activity inference of scRNA-seq data. In this documentation, we will walk you through every analysis that scMINER can do and introduce you more about the concepts related to scMINER framework. "],["introduction.html", "Chapter 1 Introduction 1.1 A few concepts 1.2 Why use scMINER 1.3 Citation 1.4 Support", " Chapter 1 Introduction This chapter will introduce 1.1 A few concepts There are a few concepts that may help you understand scMINER better. SparseEset Mutual Information Gene Activity 1.2 Why use scMINER (more deteils to be added) scMINER includes the following key functions: Mutual information-based clustering: scMINER measures the cell-cell similarities with full feature-derived mutual information. It can catch both linear and non-linear correlations and performs better in cell clustering, especially for those of close states. Gene activity estimation: scMINER rewires the cell-type specific gene networks solely from the scRNA-seq data, and then estimates the gene activities of not only transcription factors (TFs) but also signaling genes (SIGs). The gene activity-based analysis can expose the main regulators of various biological activities, like cellular linage differentiation and tissue specificity. SparseEset-centered full-feature tool: scMINER provides a wide range of functions for data intake, quality control and filtration, MI-based clustering, network inference, gene activity estimation, cell type annotation, differential expression/activity analysis, and data visualization and sharing. Most of these functions are developed in an object-oriented manner for the SparseEset object. 1.3 Citation Please consider citing this paper if you find scMINER useful in your research. 1.4 Support We welcome your feedback! The scMINER software is developed and maintained by the Yu Lab @ St. Jude Children’s Research Hospital and is released under the Apache License (Version 2.0). Feel free to open an issue, or send us an email if you encounter a bug, need our help or just want to make a comment/suggestion. "],["get-started.html", "Chapter 2 Get started 2.1 Installation 2.2 Demo data 2.3 Create project space", " Chapter 2 Get started This chapter will walk you through how to install scMINER, create a project space for your study and prepare the demo data used in this tutorial. 2.1 Installation scMINER framework is mainly developed with R for its advantages in statistical analysis and data visualization. It also includes two components, MICA and SJARACNe, that are developed with Python to take its strengths in calculation speed and memory consumption, since mutual information estimation of large-scale scRNA-seq data is usually compute-intensive. Please install all three components for the full access to scMINER framework. Install scMINER R package The scMINER R package requires R 4.2.3 or newer, and can be installed from GitHub with: # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;https://github.com/jyyulab/scMINER.git@dev-qpan&quot;) Install MICA and SJARACNe The recommended method to install MICA and SJARACNe is to use conda dependency manager: ## setup conda env conda create -n scminer python=3.9.2 # Create a python virtual environment source activate scminer # Activate the virtual environment ## install MICA git clone https://github.com/jyyulab/MICA # Clone the MICA repo cd MICA # Switch to the MICA root directory pip install . # Install MICA and its dependencies mica -h # Check if MICA works ## install SJARACNE cd .. # Switch to conda env folder git clone https://github.com/jyyulab/SJARACNe.git # Clone the SJARACNe repo cd SJARACNe # Switch to the MICA root directory python setup.py build # Build SJARACNe binary python setup.py install # Build SJARACNe binary sjaracne -h # Check if SJARACNe works 2.2 Demo data In this tutorial, we will use a ground truth dataset called PBMC14k for demonstration purposes. It was generated from a Peripheral Blood Mononuclear Cells (PBMCs) dataset containing 10 known cell types, with 2,000 cells per type [Zheng et al., 2017]: We first rectified the gene symbol issues of the original dataset, including the dash-dot conversion (e.g. “RP11-34P13.7” changed to “RP11.34P13.7”) and “X” added to those started with numbers (e.g. “7SK” changed to “X7SK”), by referring to the gene annotation file (GRCh37.82) used in the original study. Then we removed 3 cell populations, CD34+ cells, CD4+ helper T cells, and total CD8+ cytotoxic cells, from the dataset because of either low sorting purity or a significant overlap with other immune cells based on the sorting strategy, and created a new dataset with seven known cell types and 14k cells in total. The original dataset is freely available under this accession number SRP073767 and Zenodo. How was the PBMC14K dataset generated from the original dataset? ## Step 1: rectify the invalid gene symbols # &quot;Filtered_DownSampled_SortedPBMC_data.csv&quot; is the raw count matrix directly downloaded from Zenodo counts &lt;- read.csv(&quot;Filtered_DownSampled_SortedPBMC_data.csv&quot;, row.names = 1) d &lt;- t(counts); dim(d) # it includes 21592 genes and 20000 cells # &quot;genesymbol_from_GTF_GRCh37.txt&quot; contains the official gene ids and symbols extracted from GTF file downloaded from officialGene &lt;- read.table(&quot;genesymbol_from_GTF_GRCh37.txt&quot;, header = T, sep = &quot;\\t&quot;, quote = &quot;&quot;, stringsAsFactors = F); head(officialGene) https://ftp.ensembl.org/pub/grch37/current/gtf/homo_sapiens/ officialGene$dotted_symbol &lt;- gsub(&quot;-&quot;, &quot;\\\\.&quot;, officialGene$gene_name); officialGene$dotted_symbol &lt;- make.unique(officialGene$dotted_symbol) table(row.names(d) %in% officialGene$dotted_symbol); row.names(d)[! row.names(d) %in% officialGene$dotted_symbol] # two genes are not in: X7SK.1 and X7SK.2 row.names(d) &lt;- gsub(&quot;X7SK.1&quot;, &quot;7SK&quot;, row.names(d)); row.names(d) &lt;- gsub(&quot;X7SK.2&quot;, &quot;7SK.1&quot;, row.names(d)) table(row.names(d) %in% officialGene$dotted_symbol) # all true row.names(officialGene) &lt;- officialGene$dotted_symbol officialGene &lt;- officialGene[row.names(d),] row.names(d) &lt;- make.unique(officialGene$gene_name) # &quot;Labels.csv&quot; contains the true labels of cell types and was directly downloaded from Zenodo celltype &lt;- read.csv(&quot;Labels.csv&quot;); head(celltype); table(celltype$x) # 2000 cells for each of 10 cell types: CD14+ Monocyte, CD19+ B, CD34+, CD4+ T Helper2, CD4+/CD25 T Reg, CD4+/CD45RA+/CD25- Naive T, CD4+/CD45RO+ Memory, CD56+ NK, CD8+ Cytotoxic T, CD8+/CD45RA+ Naive Cytotoxic df &lt;- data.frame(cell_barcode = colnames(d), trueLabel_full = celltype$x); dim(df) truelabel_map &lt;- c(`CD14+ Monocyte`=&quot;Monocyte&quot;, `CD19+ B`=&quot;B&quot;, `CD34+`=&quot;CD34pos&quot;, `CD4+ T Helper2`=&quot;CD4Th2&quot;, `CD4+/CD25 T Reg`=&quot;CD4Treg&quot;, `CD4+/CD45RA+/CD25- Naive T`=&quot;CD4TN&quot;, `CD4+/CD45RO+ Memory`=&quot;CD4TCM&quot;, `CD56+ NK`=&quot;NK&quot;, `CD8+ Cytotoxic T`=&quot;CD8CTL&quot;, `CD8+/CD45RA+ Naive Cytotoxic`=&quot;CD8TN&quot;) df$trueLabel &lt;- as.character(truelabel_map[df$trueLabel_full]) ## Step 2: extract 7 populations df.14k &lt;- df[df$trueLabel_full %in% c(&quot;CD14+ Monocyte&quot;, &quot;CD19+ B&quot;, &quot;CD4+/CD25 T Reg&quot;, &quot;CD4+/CD45RA+/CD25- Naive T&quot;, &quot;CD4+/CD45RO+ Memory&quot;, &quot;CD56+ NK&quot;, &quot;CD8+/CD45RA+ Naive Cytotoxic&quot;),] write.table(df.14k, file = &quot;PBMC14k_trueLabel.txt&quot;, sep = &quot;\\t&quot;, row.names = TRUE, col.names = TRUE, quote = FALSE, append = FALSE) d.14k &lt;- d[,df.14k$cell_barcode] d.14k &lt;- d.14k[rowSums(d.14k) &gt; 0,] write.table(d.14k, file = &quot;PBMC14k_rawCount.txt&quot;, sep = &quot;\\t&quot;, row.names = FALSE, col.names = TRUE, quote = FALSE, append = FALSE) # 17986 genes, 14000 cells The PBMC14k dataset is embeded in scMINER R package and can be easily loaded by: library(scMINER) data(&quot;pbmc14k_rawCount&quot;) dim(pbmc14k_rawCount) ## [1] 17986 14000 pbmc14k_rawCount[1:5,1:5] ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## CACTTTGACGCAAT GTTACGGAAACGAA AGTCACGACAGGAG TTCGAGGACCAGTA ## AL627309.1 . . . . ## AP006222.2 . . . . ## RP11-206L10.3 . . . . ## RP11-206L10.2 . . . . ## RP11-206L10.9 . . . . ## CACTTATGAGTCGT ## AL627309.1 . ## AP006222.2 . ## RP11-206L10.3 . ## RP11-206L10.2 . ## RP11-206L10.9 . 2.3 Create project space The project space created by scMINER is a folder of specified name in specified directory. It contains 4 subfolders: DATA: to save the sparse eSet objects and other files; MICA: to save the inputs and outputs of mutual information-based clustering analysis; SJARACNe: to save the inputs and outputs of network inference and quality control; PLOT: to save the files of data visualization. The project space can not only keep your data centralized and organized, but also make the scMINER pipeline more smooth and robust. We strongly recommend you to create a project space for each of your studies. This can be easily done by createProjectSpace() in scMINER: scminer_dir &lt;- createProjectSpace(project_dir = &quot;/your-path&quot;, project_name = &quot;PBMC14k&quot;) The command above will create a folder named PBMC14k in /your-path, and save the path to the project space (/your-path/PBMC14k) to scminer_dir. Can I add, delete or modify files in project space folder? Yes, you can. There are two functions, drawNetworkQC() and getActivityBatch(), that take directories as inputs, and both of them can validate the inputs. For all the rest functions, the inputs are specific files. So adding files in project space never affect the scMINER analysis. Deleting or modifying files in project spare is also safe. The input validation features of scMINER functions can help locate the files with issues. All output files of scMINER are reproducible and can be re-generated quickly. Just be careful with the clustering results in MICA and network files in SJARACNe, ad regerating them can take some time. "],["data-intake.html", "Chapter 3 Data intake 3.1 Genereate gene expression matrix", " Chapter 3 Data intake In this chapter, we will introduce you how to create the SparseExpressionSet(SparseEset) objects from inputs of multiple formats. 3.1 Genereate gene expression matrix scMINER provides portable functions to generate the gene expression matrix from 4 most common file formats of scRNA-seq data, including sparse matrix by 10x Genomics, text-table file, HDF5 file by 10x Genomics and H5AD file. 3.1.1 From data directory by 10x Genomics This is the most popular input format of scRNA-seq data generated by 10x Genomics. Usually, the data directory contains three files: matrix.mtx: a sparse matrix format containing the raw UMI count per cell-gene combination barcodes.tsv: a tab-separated matrix containing the cell barcodes features.tsv: a tab-separated matrix containing the features/genes and their annotations For more details about this format, please check out here. data_dir &lt;- system.file(&quot;extdata/demo_inputs/cell_matrix_10x&quot;, package = &quot;scMINER&quot;) list.files(path = data_dir, full.names = FALSE) ## [1] &quot;barcodes.tsv.gz&quot; &quot;features.tsv.gz&quot; &quot;matrix.mtx.gz&quot; demo1_mtx &lt;- readInput_10x.dir(input_dir = data_dir, featureType = &quot;gene_symbol&quot;, removeSuffix = TRUE, addPrefix = &quot;demo1&quot;) ## Reading 10x Genomcis data from: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library/scMINER/extdata/demo_inputs/cell_matrix_10x ... ## Multiple data modalities were found: Gene Expression, Peaks . Only the gene expression data (under &quot;Gene Expression&quot;) was kept. ## Done! The sparse gene expression matrix has been generated: 500 genes, 100 cells. demo1_mtx[1:5,1:5] ## 5 x 5 sparse Matrix of class &quot;dgTMatrix&quot; ## demo1_AAACAGCCAAACGGGC demo1_AAACAGCCAACTAGCC demo1_AAACAGCCAATTAGGA ## AL590822.3 . . . ## MORN1 . . . ## AL589739.1 . . . ## AL513477.2 . . . ## RER1 . . . ## demo1_AAACAGCCAGCCAGTT demo1_AAACATGCAAAGCTCC ## AL590822.3 . . ## MORN1 . . ## AL589739.1 . . ## AL513477.2 . . ## RER1 1 . The readInput_10x.dir() function can handle these conditions: Alternative file names for feature data: for the datasets generated by CellRanger 3.0 or earlier, the file name is genes.tsv; Compressed input files: one or more input files are compressed, usually in “.gz” format; Data with multiple modalities: like the single cell multiome data. In this case, readInput_10x.dir() only retains the data of “Gene Expression” by default. 3.1.2 From text-table file This is definitely the most compatible text format for scRNA-seq data. which can be used by all single-cell RNA-seq technologies, like 10x Genomics, Smart-Seq, Drop-Seq and more. The commonly used text table file formats include txt (text file format), csv (comma-separated values) and tsv (tab-separated values). table_file &lt;- system.file(&quot;extdata/demo_inputs/table_file/demoData3.txt.gz&quot;, package = &quot;scMINER&quot;) demo3_mtx &lt;- readInput_table(table_file = table_file, sep = &quot;\\t&quot;, is.geneBYcell = TRUE, removeSuffix = TRUE, addPrefix = &quot;demo3&quot;) # set is.geneBYcell = FALSE to read features in columns and cell in in rows NOTE: A major concern to read the gene expression matrix from text-table files is that the special characters in column names might be changed to dots (“.”), especially when the matrix is organized in cells by genes. This may cause failures in the identification of mitochondrial genes (usually defined by “MT-|mt-”) or spike-in RNAs (usually defined by “ERCC-|Ercc-”). The readInput_table() function has set check.names = FALSE to avoid this issue. However, if this issue already exists in the source data, you will have to fix it manually. 3.1.3 From HDF5 file by 10x Genomics This is another popular input format of scRNA-seq data generated by 10x Genomics. The Hierarchical Data Format version 5 (HDF5 or H5) is a binary format that can compress and access data much more efficiently than text formats. It’s super useful when dealing with large datasets. For more details about this format, please check out here. h5_file &lt;- system.file(&quot;extdata/demo_inputs/hdf5_10x/demoData2.h5&quot;, package = &quot;scMINER&quot;) demo2_mtx &lt;- readInput_10x.h5(h5_file = h5_file, featureType = &quot;gene_symbol&quot;, removeSuffix = TRUE, addPrefix = &quot;demo2&quot;) NOTE: The readInput_10x.h5() function is developed exclusively for the HDF5 file generated by CellRanger of 10x Genomics. The HDF5 files from other source may have different hierarchical structures and can not be read by this function. 3.1.4 From H5AD file The H5AD file is another well-used format for scRNA-seq data. Derived from HDF5 file format, the H5AD file is designed to store large amounts of data efficiently and to facilitate fast access to subsets of the data. Now it’s getting more and more popular in scRNA-seq data analysis, visualization and sharing. For more details about this format, please check out here. h5ad_file &lt;- system.file(&quot;extdata/demo_inputs/h5ad_file/demoData4.h5ad&quot;, package = &quot;scMINER&quot;) demo4_obj &lt;- readInput_h5ad(h5ad_file = h5ad_file, removeSuffix = TRUE, addPrefix = &quot;demo4&quot;) # set is.geneBYcell = FALSE to read features in columns and cell in in rows NOTE: Unlike the other three readInput functions which return a gene expression matrx, the readInput_h5ad() returns an AnnData object. Here are the key components of an AnnData object: X: the primary data matrix, cells by genes; obs: observations (cells) metadata; var: variables (features/genes) metadata. "],["footnotes-and-citations.html", "Chapter 4 Footnotes and citations 4.1 Footnotes 4.2 Citations", " Chapter 4 Footnotes and citations 4.1 Footnotes Footnotes are put inside the square brackets after a caret ^[]. Like this one 1. 4.2 Citations Reference items in your bibliography file(s) using @key. For example, we are using the bookdown package [@R-bookdown] (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and knitr [@xie2015] (this citation was added manually in an external file book.bib). Note that the .bib files need to be listed in the index.Rmd with the YAML bibliography key. The RStudio Visual Markdown Editor can also make it easier to insert citations: https://rstudio.github.io/visual-markdown-editing/#/citations This is a footnote.↩︎ "],["blocks.html", "Chapter 5 Blocks 5.1 Equations 5.2 Theorems and proofs 5.3 Callout blocks", " Chapter 5 Blocks 5.1 Equations Here is an equation. \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{5.1} \\end{equation}\\] You may refer to using \\@ref(eq:binom), like see Equation (5.1). 5.2 Theorems and proofs Labeled theorems can be referenced in text using \\@ref(thm:tri), for example, check out this smart theorem 5.1. Theorem 5.1 For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] Read more here https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html. 5.3 Callout blocks The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html "],["sharing-your-book.html", "Chapter 6 Sharing your book 6.1 Publishing 6.2 404 pages 6.3 Metadata for sharing", " Chapter 6 Sharing your book 6.1 Publishing HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html 6.2 404 pages By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you’d like to customize your 404 page instead of using the default, you may add either a _404.Rmd or _404.md file to your project root and use code and/or Markdown syntax. 6.3 Metadata for sharing Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the index.Rmd YAML. To setup, set the url for your book and the path to your cover-image file. Your book’s title and description are also used. This gitbook uses the same social sharing data across all chapters in your book- all links shared will look the same. Specify your book’s source repository on GitHub using the edit key under the configuration options in the _output.yml file, which allows users to suggest an edit by linking to a chapter’s source file. Read more about the features of this output format here: https://pkgs.rstudio.com/bookdown/reference/gitbook.html Or use: ?bookdown::gitbook "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
